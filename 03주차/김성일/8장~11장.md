# 8장 통합테스트를 하는 이유

-   통합테스트는  단위테스트가 아닌 테스트를 의미
-   의존성
    -   관리 의존성
        -   DB와 같이 직접 관리할 수 있는 의존성
        -   실제 인스턴스를 사용
    -   비관리 의존성
        -   SMTP나 외부 API와 같이 직접 관리할 수 없는 의존성 
        -   목을 사용
    -   관리이면서 비관리 의존성
        -   비관리 의존성의 식별 가능한 부분을 비관리 의존성으로 간주하고, 테스트에서는 목으로 대체
        -   나머지 부분은 관리 의존성으로 간주
-   구현이 하나 뿐인 인터페이스는 추상화가 아니고, YAGNI를 위배한다.
    -   구현이 하나 뿐인 것의 타당한 이유는 목을 위한 것. 관리 의존성은 구체 클래스에 의존하고, 비관리 의존성은 인터페이스에 의존해라.



# 9장 목 처리에 대한 모범 사례

-   시스템 끝에서만 비관리 의존성과의 상호작용을 검증하라.
    -   이로써 회귀방지와 리팩터링 내성을 향상할 수 있다.
-   스파이는 직접 작성한 목으로, 시스템 끝에 있는 클래스에는 스파이가 목보다 낫다.
-   목은 비관리 의존성만을 위한 것으로, 통합 테스트에서만 사용해야한다. 단위테스트에서는 목을 사용하지 말라.



# 10장 데이터 베이스 테스트

-   데이터베이스 스키마를 형상 관리 시스템에 저장하라.
-   가능하면, 작업 단위 패턴을 사용하라.
-   준비, 실행, 검증 구절에 각각 고유의 트랜잭션이나 작업 단위가 있어야한다.
-   테스트 DB는 실제 환경과 유사해야한다. 인메모리 데이터베이스를 사용하지 말라.
-   읽기 테스트의 임계치는 쓰기 테스트보다 높아야한다. 중요한 것만 테스트하고 나머지는 무시하자.



# 11장 단위 테스트 안티 패턴

-   비공개 메서드를 테스트하게 되면, 구현에 결합되고 리팩터링 내성이 떨어진다. 식별할 수 있는 동작으로 간접적으로 테스트하라.
-   비공개 메서드가 너무 복잡하여 간접적으로 테스트하기 어렵다면, 추상화가 누락된 것. 별도 클래스로 분리하라.

-   테스트에 특정 구현을 암시하지말라. 도메인 지식을 테스트에 유출하지 말라.
-   테스트만을 위한 코드를 제품 코드에 추가하지 말라. 그것은 코드 오염이다.
-   기능을 지키기 위해 구체 클래스를 목으로 처리하지 말라. 도메인 로직이 있는 클래스와 외부 의존성과 통신하는 클래스로 분리하라.

