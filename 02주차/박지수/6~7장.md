# 6장) 단위 테스트 스타일

### 3가지의 단위 테스트 스타일

- 출력 기반 테스트 (가장 높은 품질의 테스트)
    - 숨은 입출력이 없이, SUT의 입력을 통해서만 출력 값이 정해지는 함수를 테스트
- 상태 기반 테스트
    - 작업 이 진행된 이후 시스템의 변경된 상태를 확인하는 테스트
- 통신 기반 테스트
    - 협력자 간의 통신을 목을 통해 확인하는 테스트

- 출력 기반 테스트를 고전/런던파 모두 사용한다.
    - 고전파는 상태 기반 테스트 선호
    - 런던파는 통신 기반 테스트 선호

### 함수형 프로그래밍/아키텍처

- 함수형 프로그래밍을 통해 다른 테스트에서 출력 기반 테스트로 전환할 수 있다.
    - 함수형 프로그래밍은 수학적인 함수로 만들어가는 프로그래밍이다.
        - 수학점인 함수: 오로지 입력만 사용하여 출력을 만들 수 있고 숨은 입출력이 없다.

- 함수형 프로그래밍/아키텍처를 사용하여 도메인 로직과 부작용을 분리 할 수 있다.
    - 복잡성은 도메인 로직에서
    - 외부 부작용은 연산의 가장자리로

- 도메인 로직과 부작용을 분리하여 출력 기반 테스틑 작성 할 수 있게 되었다.

# 7장) 가치 있는 단위 테스트를 위한 리팩토링

### 코드를 분류하는 기준

- 복잡도, 도메인 유의성
- 협력자 수

### 4가지 코드 유형

- 도메인 모델과 알고리즘 (복잡도 ⬆️, 협력자 수 ⬇️)
    - 단위 테스트 적용이 가장 이롭다. (테스트를 만드는데 어렵지 않음 + 꼭 테스트 해야만 하는 로직)
- 간단한 코드 (복잡도 ⬇️, 협력자 수 ⬇️)
    - 테스트할 가치가 없다. (로직을 검증하는게 아니라 단순 코드를 검증하고 있는 나를 발견하게 된다)
- 컨트롤러 (복잡도 ⬆️, 협력자 수 ⬆️)
    - 통합 테스트를 통해 간단히 테스트 해야한다.
    - 협력자가 많기 때문에 테스트 만들기 어렵지만, 통합 테스트 정도만 해주자
- 지나치게 복잡한 코드 (복잡도 ⬇️, 협력자 수 ⬆️)
    - 리팩토링을 할 때가 왔다.
    - 도메인 모델과 알고리즘 / 컨트롤러 두 개로 코드를 분할해야 한다.

### 험블 객체

외부 의존성, 협력자와의 통신을 도메인 로직과 분리하기 위해 사용

- 코드의 깊이(도메인 로직의 복잡성), 너비(협력자 수)의 관점에서 비지니스 로직/오케스트레이션 책임을 생각해야한다.
- 의사 결정 프로세트 단계를 더 세분화 하자
    - CanExecute/Execute 패턴 사용
    - 도메인 이벤트를 사용한 변경 사항 추적
