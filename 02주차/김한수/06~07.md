# 06~07

- [06~07](#0607)
- [06. 단위 테스트 스타일](#06-단위-테스트-스타일)
  - [단위 테스트의 세 가지 테스트 스타일](#단위-테스트의-세-가지-테스트-스타일)
    - [세 가지 테스트 스타일 비교하기](#세-가지-테스트-스타일-비교하기)
  - [함수형 프로그래밍과 테스트](#함수형-프로그래밍과-테스트)
  - [함수형 아키텍처](#함수형-아키텍처)
- [07. 가치 있는 단위 테스트를 위한 리팩터링](#07-가치-있는-단위-테스트를-위한-리팩터링)
  - [코드 복잡도](#코드-복잡도)
  - [네 가지 코드 유형 알아보기](#네-가지-코드-유형-알아보기)
  - [험블 객체 패턴](#험블-객체-패턴)
  - [비즈니스 로직과 오케스트레이션 분리](#비즈니스-로직과-오케스트레이션-분리)

# 06. 단위 테스트 스타일

아래 내용에 대해서 알아보자

- `단위 테스트 스타일 비교`
- `함수형 아키텍처와 육각형 아키텍처의 관계`
- `출력 기반 테스트로 전환`

## 단위 테스트의 세 가지 테스트 스타일

- `출력 기반 테스트`
  - SUT에 입력을 주고 출력을 확인하는 테스트 스타일
  - 숨은 입출력이 없다고 가정하고, SUT 작업의 결과는 반환하는 값뿐이다.
- `상태 기반 테스트`
  - 작업이 완료된 후의 시스템 상태를 확인하는 테스트 스타일
- `통신 기반 테스트`
  - 목을 사용해서 테스트 대상 시스템과 협력자 간의 통신을 검증한다.

**단위 테스트의 고전파는 통신 기반 스타일보다는 상태 기반 스타일을 선호한다.**

- 런던파는 반대를 선호한다.
- 두 분파 모두 출력 기반 테스트를 사용한다.

### 세 가지 테스트 스타일 비교하기

- `출력 기반 테스트`
  - **테스트 품질이 가장 좋다.**
  - 이러한 테스트는 구현 세부 사항에 거의 결합되지 않으므로 리팩터링 내성이 있다. 또한 작고 간결하므로 유지 보수하기도 쉽다.
- `상태 기반 테스트`
  - 이 테스트 스타일을 선택하기 전에 안정성을 위해 더 신중해야 한다.
  - 단위 테스트를 하려면 비공개 상태를 노출하지 않도록 해야 한다.
  - 상태 기반 테스트는 출력 기반 테스트보다 크기가 큰 편이므로 유지 보수가 쉽지 않다.
  - 헬퍼 메서드와 값 객체를 사용해 유지 보수성 문제를 완화할 수도 있지만 제거할 수는 없다.
- `통신 기반 테스트`
  - 상태 기반 테스트와 동일하게 안정성을 위해 더 신중해야 한다.
  - 애플리케이션 경계를 넘어서 외부 환경에 사이드 이펙트가 보이는 통신만 확인해야 한다.
  - 통신 기반 테스트의 유지 보수성은 출력 기반 테스트 및 상태 기반 테스트와 비교했을 때 좋지 않다.
  - 목은 공간을 많이 차지하는 경향이 있어 테스트 가독성이 떨어진다.

## 함수형 프로그래밍과 테스트

- `함수형 프로그래밍`은 수학적 함수로 된 프로그래밍이다.
  - 수학적 함수는 `숨은 입출력`이 없는 함수(or 메서드)
  - **사이드 이펙트와 예외**가 `숨은 출력`에 해당하고
  - **내부 상태 또는 외부 상태에 대한 참조**는 `숨은 입력`이다.
  - 수학적 함수는 명시적이므로 테스트 용이성을 상당히 높인다.
- 함수형 프로그래밍의 목표는 `비즈니스 로직과 사이드 이펙트를 분리`하는 것 !
  - 함수형 아키텍처는 사이드 이펙트를 비즈니스 연산의 가장자리로 밀어내 분리를 이루는 데 도움이 된다.
  - 이 방법으로, 사이드 이펙트를 다루는 코드를 최소화하면서 순수 함수 방식으로 작성된 코드의 양을 최대화할 수 있다.

## 함수형 아키텍처

- 함수형 아키텍처는 모든 코드를 `함수형 코어`와 `가변 셸` 이라는 두 범주로 나눈다.
  - `가변 셸`은 입력 데이터를 함수형 코어에 공급하고, 코어가 내린 결정을 사이드 이펙트로 변환한다
- 함수형 아키텍처와 육각형 아키텍처의 차이는 **사이드 이펙트의 처리**에 있다.
  - 함수형 아키텍처는 모든 사이드 이펙트를 도메인 계층 밖으로 밀어낸다.
  - 이와 반대로 육각형 아키텍처는 도메인 계층에만 한정돼 있는 한은 도메인 계층에 의해 만들어진 사이드 이펙트도 괜찮다.
  - 극단적으로는 함수형 아키텍처는 육각형 아키텍처로 볼 수도 있다.
- 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 **성능과 코드 유지 보수성 사이의 절충**이며,
**함수형 아키텍처는 유지 보수성 향상을 위해 성능을 희생한다.**
- **모든 코드베이스를 함수형 아키텍처로 전환할 수는 없다.**
  - 함수형 아키텍처를 전략적으로 적용하라.
  - 시스템의 복잡도와 중요성을 고려하라.
  - 코드베이스가 단순하거나 그렇게 중요하지 않으면, 함수형 아키텍처에 필요한 초기 투자는 별 효과가 없다. (경제적으로 생각해라)

# 07. 가치 있는 단위 테스트를 위한 리팩터링

아래 내용에 대해서 알아보자

- `네 가지 코드 유형을 알아보기`
- `험블 객체 패턴 이해`
- `가치 있는 테스트 작성`

## 코드 복잡도

- `코드 복잡도`는 코드에서 **의사 결정 지점 수**에 따라 명시적으로 그리고 암시적으로 정의된다.
- `도메인 유의성`은 프로젝트의 문제 도메인에 대해 코드가 얼마나 중요한지를 보여준다.
  - 복잡한 코드는 종종 도메인 유의성이 높고 그 반대의 경우도 있지만, 모든 경우에 100% 해당하지는 않는다.
  - **복잡한 코드와 도메인 유의성을 갖는 코드는**
    **해당 테스트의 회귀 방지가 뛰어나기 때문에 단위 테스트에서 가장 이롭다.**
- `협력자가 많은 코드`를 다루는 단위 테스트는 유지비가 많이 든다.
  - 이러한 테스트는 협력자를 예상 상태로 만들고 나서 상태나 상호 작용을 확인하고자 공간을 많이 필요로 한다.

## 네 가지 코드 유형 알아보기

- **모든 제품 코드는 복잡도 또는 도메인 유의성과 협력자 수에 따라 네 가지 유형의 코드로 분류할 수 있다.**
  - `도메인 모델 및 알고리즘`
    - **단위 테스트에 대한 노력 대비 가장 이로움**
    - 복잡도 또는 도메인 유의성이 높고
    - 협력자 거의 없음
  - `간단한 코드`
    - **테스트할 가치가 전혀 없음**
    - 복잡도와 도메인 유의성이 낮고 협력자 거의 없음
  - `컨트롤러`
    - **통합 테스트를 통해 간단히 테스트해야함**
    - 복잡도와 도메인 유의성이 낮고
    - 협력자가 많음
  - `지나치게 복잡한 코드`
    - **컨트롤러와 복잡한 코드로 분할해야 함**
    - 복잡도 또는 도메인 유의성이 높음
    - 협력자가 많음
- 코드가 중요하거나 복잡할수록 협력자가 적어야 한다.

## 험블 객체 패턴

- `험블 객체 패턴`은 해당 코드에서 비즈니스 로직을 별도의 클래스로 추출해 복잡한 코드를 테스트할 수 있는데 도움이 된다.
  - 그 결과, 나머지 코드는 비즈니스 로직을 둘러싼 얇은 험블 래퍼, 즉 `컨트롤러`가 된다.
- 육각형 아키텍처와 함수형 아키텍처는 사실 험블 객체 패턴을 구현한다.
  - 육각형 아키텍처는 비즈니스 로직과 프로세스 **외부 의존성과의 통신을 분리**하도록 한다.
  - 함수형 아키텍처는 프로세스 **외부 의존성뿐만 아니라 모든 협력자와의 통신과 비즈니스 로직을 분리**한다.
- 코드의 깊이와 너비의 관점에서 비즈니스 로직과 오케스트레이션 책임을 생각하라.
  - 코드는 깊을 수도 있고(복잡하거나 중요함) 넓을 수도 있지만(협력자가 많음), 둘 다는 아니다.
- 도메인 유의성이 있으면 전제 조건을 테스트하고, 그 외의 경우에는 테스트하지 않는다.

## 비즈니스 로직과 오케스트레이션 분리

- 비즈니스 로직과 오케스트레이션을 분리할 때는 다음과 같이 세 가지 중요한 특성이 있다.
  - `도메인 모델 테스트 용의성`
    - 도메인 클래스 내 협력자 수와 유형에 대한 함수
  - `컨트롤러 단순성`
    - 컨트롤러에 의사 결정 지점이 있는지에 따라 다름
  - `성능`
    - 프로세스 외부 의존성에 대한 호출 수로 정의
- 그리고 **위 특성 중 항상 세가지 특성 중 최대 두가지를 가질 수 있다.**
  - `외부에 대한 모든 읽기와 쓰기를 비즈니스 연산 가장자리로 밀어내기`
    - 컨트롤러를 단순하게 유지하고 도메인 모델 테스트 유의성을 지키지만, 성능이 저하됨
  - `도메인 모델에 프로세스 외부 의존성을 주입하기`
    - 성능을 유지하고 컨트롤러를 단순하게 하지만, 도메인 모델의 테스트 유의성이 떨어짐
  - `의사 결정 프로세스 단계를 더 세분화하기`
    - 성능과 도메인 모델 테스트 유의성을 지키지만, 컨트롤러의 단순함을 포기
- 결론적으로 `의사 결정 프로세스 단계를 더 세분화하는 것`이 장단점을 고려할 때 가장 효과적인 절충임.
  - 다음 두 가지 패턴을 사용해 컨트롤러 복잡도 증가를 완화할 수 있음
    - `CanExecute/Execute 패턴`
      - 각 Do() 메서드에 대해 CanDo()를 두고, CanDo()가 성공적으로 실행되는 것을 Do()의 전제 조건으로 함.
      - 이 패턴은 Do() 전에 CanDo()를 호출하지 않을 수 없기 때문에 컨트롤러의 의사 결정을 근본적으로 제거함
    - `도메인 이벤트`
      - 도메인 모델의 중요한 변경 사항을 추적하고 해당 변경 사항을 프로세스 외부 의존성에 대한 호출로 변환함
      - 이 패턴으로 컨트롤러에서 추적에 대한 책임이 없어짐
- **추상할 것을 테스트하기보다는 추상화를 테스트하는 것이 더 쉬움.**
  - 도메인 이벤트는 프로세스 외부 의존성 호출 위의 추상화에 해당함.
  - 도메인 클래스의 변경은 데이터 저장소의 향후 수정에 대한 추상화에 해당함
